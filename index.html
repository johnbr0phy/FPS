<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel FPS Demo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #59b7ff; /* Sky blue */ color: white; font-family: sans-serif; }
        canvas { display: block; cursor: crosshair; background-color: #59b7ff; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
            color: white;
            z-index: 10;
        }
        #instructions ul { margin: 5px 0 0 15px; padding: 0; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="instructions">
        <strong>Controls:</strong>
        <ul>
            <li>WASD: Move Horizontally</li>
            <li>Space: Move Up</li>
            <li>Shift: Move Down</li>
            <li>Mouse: Look Around (Pitch/Yaw)</li>
            <li>Left Click: Destroy Voxel (Click screen to lock mouse)</li>
            <li>ESC: Unlock mouse</li>
        </ul>
        Aim at a voxel and click to damage/destroy it. Performance may vary!
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); // Optimize by disabling alpha buffer if not needed
        const instructions = document.getElementById('instructions');

        // --- Game Settings ---
        let screenWidth = window.innerWidth;
        let screenHeight = window.innerHeight;
        canvas.width = screenWidth;
        canvas.height = screenHeight;

        const RENDER_SCALE = 0.5; // Render at lower resolution for performance
        let renderWidth = Math.floor(screenWidth * RENDER_SCALE);
        let renderHeight = Math.floor(screenHeight * RENDER_SCALE);
        // We'll draw to an offscreen canvas then scale up
        const offscreenCanvas = new OffscreenCanvas(renderWidth, renderHeight);
        const offscreenCtx = offscreenCanvas.getContext('2d', { alpha: false });


        // --- World Settings ---
        const worldWidth = 32;
        const worldHeight = 32; // Vertical dimension
        const worldDepth = 32;
        const voxels = new Uint8Array(worldWidth * worldHeight * worldDepth); // Use TypedArray for efficiency
        const voxelHealth = new Uint8Array(worldWidth * worldHeight * worldDepth);
        const MAX_VOXEL_HEALTH = 4;
        const RENDER_DISTANCE = 20; // Max distance to cast rays

        const voxelTypes = {
            AIR: 0,
            DIRT: 1,
            GRASS: 2,
            STONE: 3,
            WOOD: 4,
        };

        const voxelColors = [
            null, // Air
            { r: 139, g: 69, b: 19 },  // Dirt (Brown)
            { r: 34, g: 139, b: 34 },  // Grass (ForestGreen)
            { r: 128, g: 128, b: 128 },// Stone (Gray)
            { r: 160, g: 82, b: 45 },  // Wood (Sienna)
        ];
        const healthColors = [ // Tints towards red as health decreases
            { r: 255, g: 100, b: 100 }, // Health 1
            { r: 255, g: 180, b: 100 }, // Health 2
            { r: 200, g: 200, b: 100 }, // Health 3
            // Health 4 uses base color
        ];


        function getVoxelIndex(x, y, z) {
             if (x < 0 || x >= worldWidth || y < 0 || y >= worldHeight || z < 0 || z >= worldDepth) {
                return -1; // Out of bounds
            }
            // Y is height, so it changes fastest in typical nested loops, but here XZ is the plane
            return Math.floor(x) + Math.floor(z) * worldWidth + Math.floor(y) * worldWidth * worldDepth;
        }

        function getVoxel(x, y, z) {
            const index = getVoxelIndex(x, y, z);
            return index === -1 ? voxelTypes.AIR : voxels[index];
        }

        function setVoxel(x, y, z, type, health = MAX_VOXEL_HEALTH) {
            const index = getVoxelIndex(x, y, z);
            if (index !== -1) {
                voxels[index] = type;
                voxelHealth[index] = type === voxelTypes.AIR ? 0 : health;
            }
        }

        function damageVoxel(x, y, z) {
             const index = getVoxelIndex(x, y, z);
             if (index !== -1 && voxels[index] !== voxelTypes.AIR) {
                 if (voxelHealth[index] > 0) {
                     voxelHealth[index]--;
                     console.log(`Voxel at [${x},${y},${z}] health: ${voxelHealth[index]}`);
                     if (voxelHealth[index] <= 0) {
                         console.log(`Voxel at [${x},${y},${z}] destroyed!`);
                         setVoxel(x, y, z, voxelTypes.AIR, 0);
                         return true; // Was destroyed
                     }
                 }
                 return false; // Was damaged but not destroyed
             }
             return false; // No voxel to damage or already air
        }


        // Simple world generation
        function createWorld() {
            console.log("Creating world...");
            for (let y = 0; y < worldHeight; y++) {
                for (let z = 0; z < worldDepth; z++) {
                    for (let x = 0; x < worldWidth; x++) {
                        const height = Math.floor(worldHeight / 3);
                         let voxelType = voxelTypes.AIR;
                         let health = 0;

                        if (y < height) {
                            voxelType = voxelTypes.STONE;
                        } else if (y === height) {
                             voxelType = voxelTypes.GRASS;
                        }
                        // Add some random pillars
                        if (voxelType === voxelTypes.AIR && Math.random() < 0.005 && y < worldHeight * 0.6) {
                             if (x > 2 && x < worldWidth - 2 && z > 2 && z < worldDepth - 2) { // Avoid edges
                                for (let py = y; py < y + Math.floor(Math.random() * 5) + 3; py++) {
                                     if (py < worldHeight) setVoxel(x, py, z, voxelTypes.WOOD);
                                }
                             }
                        } else {
                             setVoxel(x, y, z, voxelType);
                        }
                    }
                }
            }
             console.log("World created.");
        }

        // --- Player State ---
        const player = {
            x: worldWidth / 2 + 0.5,
            y: worldHeight / 3 + 2.5, // Start above ground
            z: worldDepth / 2 + 0.5,
            yaw: Math.PI, // Look forward initially (radians)
            pitch: 0,   // Look straight ahead (radians)
            speed: 0.08,
            rotSpeed: 0.002, // Mouse sensitivity
            bobbingAngle: 0,
            bobbingAmount: 0.02,
            isMoving: false,
            height: 1.6,
            width: 0.4
        };

        // --- Input State ---
        const keys = {};
        let mouseDeltaX = 0;
        let mouseDeltaY = 0;
        let pointerLocked = false;

        // --- Game Loop ---
        let lastTime = 0;
        function gameLoop(timestamp) {
            const deltaTime = Math.min(0.05, (timestamp - lastTime) / 1000); // Delta time in seconds, capped to prevent jumps
            lastTime = timestamp;

            update(deltaTime);
            render();

            requestAnimationFrame(gameLoop);
        }

        // --- Update Function ---
        function update(deltaTime) {
            // Mouse look
            if (pointerLocked) {
                player.yaw += mouseDeltaX * player.rotSpeed;
                player.pitch -= mouseDeltaY * player.rotSpeed;

                // Clamp pitch to prevent looking upside down/too far down
                player.pitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, player.pitch));

                mouseDeltaX = 0;
                mouseDeltaY = 0;
            }

            // Movement direction based on yaw
            const cosYaw = Math.cos(player.yaw);
            const sinYaw = Math.sin(player.yaw);
            let moveX = 0;
            let moveZ = 0;
            let moveY = 0;

            if (keys['w']) { moveX += sinYaw; moveZ += cosYaw; }
            if (keys['s']) { moveX -= sinYaw; moveZ -= cosYaw; }
            if (keys['a']) { moveX += cosYaw; moveZ -= sinYaw; }
            if (keys['d']) { moveX -= cosYaw; moveZ += sinYaw; }
            if (keys[' ']) { moveY += 1; } // Space for Up
            if (keys['shift']) { moveY -= 1; } // Shift for Down

            player.isMoving = (moveX !== 0 || moveZ !== 0 || moveY !== 0);

            // Normalize horizontal movement
            const horizMagnitude = Math.sqrt(moveX * moveX + moveZ * moveZ);
            if (horizMagnitude > 0) {
                moveX = (moveX / horizMagnitude) * player.speed;
                moveZ = (moveZ / horizMagnitude) * player.speed;
            }
             // Apply vertical speed
            moveY *= player.speed;


            // Collision Detection (Simple Point Check) - More robust would use AABB
            const checkMargin = player.width / 2 + 0.01; // Check slightly ahead
            const nextX = player.x + moveX;
            const nextYHead = player.y + moveY + player.height * 0.8; // Check near head height
            const nextYFeet = player.y + moveY + player.height * 0.1; // Check near feet
            const nextZ = player.z + moveZ;

            // Check X movement
            if (getVoxel(nextX + Math.sign(moveX) * checkMargin, Math.floor(player.y + player.height*0.1), Math.floor(player.z)) === 0 &&
                getVoxel(nextX + Math.sign(moveX) * checkMargin, Math.floor(player.y + player.height*0.9), Math.floor(player.z)) === 0) {
                player.x = nextX;
            }
            // Check Z movement
            if (getVoxel(Math.floor(player.x), Math.floor(player.y + player.height*0.1), nextZ + Math.sign(moveZ) * checkMargin) === 0 &&
                getVoxel(Math.floor(player.x), Math.floor(player.y + player.height*0.9), nextZ + Math.sign(moveZ) * checkMargin) === 0) {
                player.z = nextZ;
            }
             // Check Y movement (Head and Feet) - Need careful checks to avoid getting stuck
            if (moveY > 0) { // Moving Up
                 if (getVoxel(Math.floor(player.x), Math.floor(nextYHead), Math.floor(player.z)) === 0) {
                    player.y += moveY;
                 }
             } else if (moveY < 0) { // Moving Down
                 if (getVoxel(Math.floor(player.x), Math.floor(nextYFeet), Math.floor(player.z)) === 0) {
                    player.y += moveY;
                 }
             }


            // Simple view bobbing
            if (player.isMoving && moveY === 0) { // Only bob when moving horizontally
                player.bobbingAngle += deltaTime * 10; // Speed of bob
            } else {
                 // Slowly return to center if not moving
                 if (player.bobbingAngle !== 0) {
                     player.bobbingAngle += (0 - player.bobbingAngle) * 0.1;
                 }
            }
        }


         // --- Voxel Ray Tracing Function ---
         // Based on "A Fast Voxel Traversal Algorithm for Ray Tracing" by Amanatides & Woo
         function traceRay(startX, startY, startZ, dirX, dirY, dirZ) {
             let currentX = Math.floor(startX);
             let currentY = Math.floor(startY);
             let currentZ = Math.floor(startZ);

             const stepX = Math.sign(dirX);
             const stepY = Math.sign(dirY);
             const stepZ = Math.sign(dirZ);

             // Avoid division by zero
             const deltaX = (dirX === 0) ? 1e30 : Math.abs(1 / dirX);
             const deltaY = (dirY === 0) ? 1e30 : Math.abs(1 / dirY);
             const deltaZ = (dirZ === 0) ? 1e30 : Math.abs(1 / dirZ);

             // Calculate initial tMax values
             let tMaxX = (stepX > 0) ? (currentX + 1 - startX) * deltaX : (startX - currentX) * deltaX;
             let tMaxY = (stepY > 0) ? (currentY + 1 - startY) * deltaY : (startY - currentY) * deltaY;
             let tMaxZ = (stepZ > 0) ? (currentZ + 1 - startZ) * deltaZ : (startZ - currentZ) * deltaZ;

             let distance = 0;
             let hitFace = -1; // 0: X, 1: Y, 2: Z

             while (distance < RENDER_DISTANCE) {
                 if (tMaxX < tMaxY) {
                     if (tMaxX < tMaxZ) {
                         distance = tMaxX;
                         tMaxX += deltaX;
                         currentX += stepX;
                         hitFace = 0;
                     } else {
                         distance = tMaxZ;
                         tMaxZ += deltaZ;
                         currentZ += stepZ;
                         hitFace = 2;
                     }
                 } else {
                     if (tMaxY < tMaxZ) {
                         distance = tMaxY;
                         tMaxY += deltaY;
                         currentY += stepY;
                         hitFace = 1;
                     } else {
                         distance = tMaxZ;
                         tMaxZ += deltaZ;
                         currentZ += stepZ;
                         hitFace = 2;
                     }
                 }

                 // Check bounds
                 if (currentX < 0 || currentX >= worldWidth ||
                     currentY < 0 || currentY >= worldHeight ||
                     currentZ < 0 || currentZ >= worldDepth) {
                     return null; // Ray left the world bounds
                 }

                 const voxelType = getVoxel(currentX, currentY, currentZ);
                 if (voxelType !== voxelTypes.AIR) {
                     // Hit! Return info
                     return {
                         x: currentX, y: currentY, z: currentZ,
                         type: voxelType,
                         distance: distance,
                         face: hitFace // Which face was hit (for basic shading)
                     };
                 }
             }
             return null; // Hit nothing within render distance
         }


        // --- Rendering Function ---
        function render() {
            // Calculate camera direction vector
            const cosPitch = Math.cos(player.pitch);
            const sinPitch = Math.sin(player.pitch);
            const cosYaw = Math.cos(player.yaw);
            const sinYaw = Math.sin(player.yaw);

            const camDirX = sinYaw * cosPitch;
            const camDirY = -sinPitch; // Y is up/down in our world
            const camDirZ = cosYaw * cosPitch;

            // Calculate camera plane (simple FOV calculation)
            const fov = Math.PI / 3; // Field of view (60 degrees)
            const aspectRatio = renderWidth / renderHeight;
            // Right vector (cross product of dir and world up [0,1,0]) - simplified
            const camPlaneX_X = cosYaw;
            const camPlaneX_Z = -sinYaw;
             // Up vector (cross product of right and dir) - derived carefully
            const camPlaneY_X = -sinYaw * sinPitch;
            const camPlaneY_Y = cosPitch;
            const camPlaneY_Z = -cosYaw * sinPitch;

            // Bobbing offset
            const bobOffset = player.isMoving ? Math.sin(player.bobbingAngle) * player.bobbingAmount : 0;
            const camY = player.y + player.height / 2 + bobOffset; // Adjust camera height + bobbing

             // Clear offscreen canvas (sky color)
             offscreenCtx.fillStyle = '#59b7ff';
             offscreenCtx.fillRect(0, 0, renderWidth, renderHeight);

             // Draw distance fog overlay (optional, cheap way to hide distant rendering cutoff)
             const fogGradient = offscreenCtx.createLinearGradient(0, 0, 0, renderHeight);
             fogGradient.addColorStop(0.4, "rgba(89, 183, 255, 0)"); // Sky color, transparent near
             fogGradient.addColorStop(0.9, "rgba(89, 183, 255, 1)"); // Sky color, opaque far
             offscreenCtx.fillStyle = fogGradient;


            // --- Ray casting loop ---
            for (let x = 0; x < renderWidth; x++) {
                // Calculate ray direction for this screen column x and row y (center for now)
                const normX = (2 * x / renderWidth - 1) * aspectRatio;

                // Center Y for now, we render columns. Could do per-pixel for better vertical accuracy but SLOW.
                const normY = 0; // (1 - 2 * y / renderHeight)

                // Combine direction and plane vectors
                const rayDirX = camDirX + camPlaneX_X * normX + camPlaneY_X * normY;
                const rayDirY = camDirY + camPlaneY_Y * normY; // Only uses pitch component if normY=0
                const rayDirZ = camDirZ + camPlaneX_Z * normX + camPlaneY_Z * normY;


                 // --- Trace the ray ---
                 const hit = traceRay(player.x, camY, player.z, rayDirX, rayDirY, rayDirZ);

                if (hit) {
                    // Calculate perceived line height
                    // Use perpendicular distance approximation (less accurate in true 3D but simpler)
                    // A better way involves dot product, but let's keep it basic
                    const perpDist = hit.distance * Math.abs(cosPitch); // Basic correction
                    const lineHeight = Math.floor(renderHeight / (perpDist + 0.01)); // Add epsilon to avoid infinity

                    // Calculate draw start/end points
                    let drawStart = Math.floor(-lineHeight / 2 + renderHeight / 2);
                    // Correct draw start based on player pitch (approximate)
                    drawStart += Math.floor(player.pitch * renderHeight * 0.2); // Adjust vertical position based on pitch
                    let drawEnd = drawStart + lineHeight;

                    // Clamp draw coordinates
                    const clampedStart = Math.max(0, drawStart);
                    const clampedEnd = Math.min(renderHeight -1, drawEnd);


                    // Choose color based on voxel type and health
                    let baseColor = voxelColors[hit.type];
                    let finalColor = { ...baseColor }; // Copy base color

                    const health = voxelHealth[getVoxelIndex(hit.x, hit.y, hit.z)];
                    if (health > 0 && health < MAX_VOXEL_HEALTH) {
                        // Lerp towards damage color based on health loss
                        const damageColor = healthColors[health - 1];
                        const ratio = (MAX_VOXEL_HEALTH - health) / (MAX_VOXEL_HEALTH -1); // 0 to 1 as health drops

                        // Simplified lerp - might not be visually perfect
                        finalColor.r = Math.floor(baseColor.r * (1-ratio) + damageColor.r * ratio);
                        finalColor.g = Math.floor(baseColor.g * (1-ratio) + damageColor.g * ratio);
                        finalColor.b = Math.floor(baseColor.b * (1-ratio) + damageColor.b * ratio);
                    }


                    // Apply simple shading based on face hit and distance
                    let shade = 1.0 - Math.min(hit.distance / RENDER_DISTANCE, 1.0) * 0.6; // Distance fog/shade
                    if (hit.face === 1) shade *= 0.7; // Top/Bottom faces darker
                    else if (hit.face === 0) shade *= 0.85; // X faces slightly darker
                    // Z faces (face == 2) get full brightness * distance shade

                    const r = Math.max(0, Math.min(255, Math.floor(finalColor.r * shade)));
                    const g = Math.max(0, Math.min(255, Math.floor(finalColor.g * shade)));
                    const b = Math.max(0, Math.min(255, Math.floor(finalColor.b * shade)));
                    offscreenCtx.fillStyle = `rgb(${r},${g},${b})`;

                    // Draw the vertical line (stripe) for this column
                    offscreenCtx.fillRect(x, clampedStart, 1, clampedEnd - clampedStart + 1);
                }
            }

             // Draw fog overlay after walls
             offscreenCtx.fillRect(0, 0, renderWidth, renderHeight);


             // --- Draw to main canvas (scaled) ---
             ctx.imageSmoothingEnabled = false; // Use nearest-neighbor for pixelated look
             ctx.drawImage(offscreenCanvas, 0, 0, renderWidth, renderHeight, 0, 0, screenWidth, screenHeight);


             // Draw crosshair on main canvas
            const crosshairSize = 15 * (screenWidth / 800); // Scale crosshair
            const centerX = screenWidth / 2;
            const centerY = screenHeight / 2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerX - crosshairSize, centerY);
            ctx.lineTo(centerX + crosshairSize, centerY);
            ctx.moveTo(centerX, centerY - crosshairSize);
            ctx.lineTo(centerX, centerY + crosshairSize);
            ctx.stroke();
        }

        // --- Shooting Logic ---
        function shoot() {
            if (!pointerLocked) return;

            // Calculate camera direction vector (same as in render)
            const cosPitch = Math.cos(player.pitch);
            const sinPitch = Math.sin(player.pitch);
            const cosYaw = Math.cos(player.yaw);
            const sinYaw = Math.sin(player.yaw);
            const camDirX = sinYaw * cosPitch;
            const camDirY = -sinPitch;
            const camDirZ = cosYaw * cosPitch;
            const camY = player.y + player.height / 2; // Use player head height for shooting origin

            const hit = traceRay(player.x, camY, player.z, camDirX, camDirY, camDirZ);

            if (hit && hit.distance < 8) { // Max shooting distance
                console.log(`Hit voxel type ${hit.type} at [${hit.x}, ${hit.y}, ${hit.z}]`);
                damageVoxel(hit.x, hit.y, hit.z);
            } else {
                console.log("Missed or out of range.");
            }
        }

        // --- Event Listeners ---
        window.addEventListener('keydown', (e) => { keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        canvas.addEventListener('click', () => {
            if (!pointerLocked) {
                canvas.requestPointerLock()
                    .catch(err => { console.error("Cannot lock pointer:", err); });
            } else {
                shoot();
            }
        });

        document.addEventListener('pointerlockchange', () => {
            if (document.pointerLockElement === canvas) {
                pointerLocked = true;
                instructions.style.display = 'none';
                document.addEventListener("mousemove", handleMouseMove, false);
            } else {
                pointerLocked = false;
                instructions.style.display = 'block';
                document.removeEventListener("mousemove", handleMouseMove, false);
                for (const key in keys) { keys[key] = false; } // Clear keys on unlock
            }
        });

        document.addEventListener('pointerlockerror', (e) => {
            console.error('Pointer lock error:', e);
            pointerLocked = false;
            instructions.style.display = 'block';
            document.removeEventListener("mousemove", handleMouseMove, false);
        });

        function handleMouseMove(e) {
            if (pointerLocked) {
                mouseDeltaX += e.movementX || 0;
                mouseDeltaY += e.movementY || 0;
            }
        }

        // Handle window resizing
        window.addEventListener('resize', () => {
            screenWidth = window.innerWidth;
            screenHeight = window.innerHeight;
            canvas.width = screenWidth;
            canvas.height = screenHeight;

            renderWidth = Math.floor(screenWidth * RENDER_SCALE);
             renderHeight = Math.floor(screenHeight * RENDER_SCALE);
             offscreenCanvas.width = renderWidth;
             offscreenCanvas.height = renderHeight;
            console.log(`Resized to: ${screenWidth}x${screenHeight} (Rendering at ${renderWidth}x${renderHeight})`);

        });

        // --- Initialization ---
        createWorld();
        requestAnimationFrame(gameLoop);

    </script>
</body>
</html>
